---
title: "Finding Features - Scale, Rotation, View Point"
categories:
  - INU-ComputerVision
tags:
  - INU-ComputerVision
toc: true
toc_sticky: true
toc_label: "Carefree to See"
header:
   teaser: "/assets/images/INU/ComputerVision/findingFeatures2_1.png"
---
<!-- Created by Chae Seung Min - CarefreeLife
Visit my Programming blog: https://carefreelife98.github.io --> 
---

# Invariant Descriptors
## Scale
![path](/assets/images/INU/ComputerVision/findingFeatures2_1.png)
> 위와 같이 두 이미지를 다른 Scale 을 가지도록 Crop (Image patches) 하였을 때, Matching 을 위해 두 이미지가 같은 특징을 갖도록 하는 방법은?<br>
> - 가장 쉬운 방법은 Crop 된 이미지를 서로 동일한 특징을 갖도록 아래와 같이 Re-scale 하는 것.<br>
> 	![path](/assets/images/INU/ComputerVision/findingFeatures2_2.png)

<br><br>

### Scale Changes 특징
> **Scale Change는 많은 시간이 소요**됨.<br>
> - 모든 경우의 수를 전부 탐색 (Exhaustive Search), 두 개의 Crop 영역이 Matching이 되는지 확인해야함.
> <br><br>
> 
> **시간 복잡도**<br>
> - **`O(N^2S)`**<br>
>     - N fearures perimage<br>
>     - S re-scalings per feature

<br><br>

### 해결 방법 : 스케일링 자동화 (Automatic Scale Selection)
> **Main Idea**<br>
> - **특정 함수 작성**<br>
>   - 각각의 Image Patch (Region) 의 입력을 받는 함수 작성.<br>	
>     - Scale Invariant 한 함수.<br>
>     - **서로 대응되는 Patch 의 Scale이 다르더라도 입력이 되었을 때 같은 값을 반환 해주어야 함.**<br>
>        - EX) **Average Intensity**<br>
>        	![path](/assets/images/INU/ComputerVision/findingFeatures2_3.png)<br>
>          - 두 Region 이 **서로 다른 Scale을 가지더라도 유사한 평균 값**을 가짐.

<br><br>

### Automatic Scale Selection 을 하기 좋은 함수
> 좌표계에서 **하나의 안정적이고 높은 Peak 가 존재** 하는 경우.<br>
> ![path](/assets/images/INU/ComputerVision/findingFeatures2_4.png)<br>
> - 여러 개의 Peak 가 존재하는 경우 ?<br>
>    - **Peak가 많으면 적합한 Scale size를 찾기 어려울 수 있음.**

<br><br>

### Peak를 찾는 방법
> **기본적인 방법은 Edge 를 찾는 Kernel 을 Convolve** 시키는 것.<br><br>
>
> - 좌표계에서 Peak (극 값) 를 찾는 것은 **급격하게 변화하는 부분**을 찾는것.<br>
> - 이는 마치 이전에 배웠던 **Edge Detection** 과 연관됨.<br>

![path](/assets/images/INU/ComputerVision/findingFeatures2_5.png)
- **Laplacian of Gaussian (LoG)** Kernel 사용.
	- Gaussian 을 두 번 미분한 것.

<br><br>

### Example : Automatic Scale Selection
1. **Image 의 Scale을 키워나가며 그래프 생성**
   ![path](/assets/images/INU/ComputerVision/findingFeatures2_6.png)
	- 적합한 Scale이 찾아지면 **x, y 좌표계로 가져와서 적절한 크기로 Noramalize** 한다.
2. 이후 해당 **Patch 들을 SSD 로 Matching** 시켜준다.
3. 마지막으로 **Warping** 을 통해 Patch Normalization을 완료한다.
   ![path](/assets/images/INU/ComputerVision/findingFeatures2_7.png)
   <br><br>

## Rotation
> **어떻게 Rotation의 강인한 (Invariant) Descriptor 를 만들 수 있는가?**<br>
> - Edge 에서 확인했던 **Harris Detector (M Matrix of Harris) 사용.**<br>
>   1. **M Matrix of Harris 에서 주요한 방향** (Dominant gradient direction) 을 찾는다.<br>
>   2. Warping 을 통해 좌표계로 옮겨 올 수 있다.<br><br>
>
>**HoG (Histogram of Gradient) descriptor**<br>
> 1. 각각의 Image에 대하여 **Gradient 계산.**<br>
> 2. 해당 Gradient 에 대한 **Histogram 작성.**<br>
> 3. 각 이미지의 **Gradient 방향을 그래프로** 보여줌.<br>
> 	- = 주요한 방향 (Dominant Gradient) 을 찾을 수 있음.<br>
> 4. 찾은 **Hog Descriptor 를 나열하여 Concatination. (결합)**

<br><br>

### Patch 의 Orientation을 계산하는 방법.
![path](/assets/images/INU/ComputerVision/findingFeatures2_8.png)
1. **Gaussian Kernel을 이용하여 전체적 이미지를 Blurr** 하게 만들어 준다. (전처리 과정)
2. **Edge - Gradient Vector 를 계산**
3. 좌표계의 **구간 (Bean) 정하기**
4. **Gradient 에 Orientation이 얼마나 존재하는 지를 Histogram** 을 통해 나타냄.
5. **Histogram 의 Local Maxima를 계산.**
6. 특정 **방향으로 Patch가 Dominant** 하게 되어있다는 것 확인.
7. **Image Warping** 실행 -> **Rotation의 Invariant 한 속성들을 구할 수 있다.**

<br><br>

## View Point
![path](/assets/images/INU/ComputerVision/findingFeatures2_9.png)
> Image 1<br>
> - 상대적으로 펼쳐져 있는 이미지.<br>
>
> Image 2<br>
> - 볼 수 있는 Receptive 한 영역이 넓음.<br>
> - 넓은 이미지를 작은 공간에 두어 찌그러져 있는 상태.<br><br>
> 이러한 상황에서 **Viewpoint 가 Invariant 하기 위해서는 Affine Warping 의 과정이 필요.**

<br><br>

### Affine Warping
> **Warping**<br>
> - **일반적으로 이미지를 변형 시키는 것을 뜻함.**<br>
> - **Affine Transform**<br><br>
> **Interpolation**<br>
> - **Warping 대상 픽셀과 인접한 픽셀들의 관계를 이용**하여 Warping.<br><br>
> - Interpolation 의 세 가지 기법<br>
>     - **Nearest neighbor interpolation**<br>
>     - **Bilinear interpolation**<br>
>     - **Bicubic interpolation**

<br><br>

#### Warping Function
![path](/assets/images/INU/ComputerVision/findingFeatures2_10.png)
> **Warping Funtion은 Rotation, Rescaling, Translation** 을 모두 포함하는 함수.<br>
> - **Rotation : 이미지 회전**<br>
> - **Rescaling : 스케일링 (배율)**<br>
> - **Translation : 이미지 이동**

<br><br>

#### Interpolation
![path](/assets/images/INU/ComputerVision/findingFeatures2_11.png)
> **이미지를 Rescaling, Resizing, Warping 하는 것에 있어 많은 영향을 줌.**

1. **Nearest neighbor**
	- 말 그대로 **가장 가까운 값을 이용해서 다른 값을 "보관 / 할당"**.
2. **Bilinear**
	- Linear : 좌표에서 직선을 생성, 그 **직선에 대하여 각 점 간의 y좌표가 얼마나 대응되는지 Linear Function 을 이용하여 계산.**
3. **Cubic**
	- **3차식을 이용**한 Interpolation 기법
	  <br><br>

# Blob Detector
## Harris Detector
![path](/assets/images/INU/ComputerVision/findingFeatures2_12.png)
> **Rotation 에 Invariant 함.**<br>
> - 주어진 이미지에 대하여 **Rotation을 시키더라도 iden-value (이미지의 형태) 는 변하지 않는다.**

<br><br>

### Harris (Corner) Detector
![path](/assets/images/INU/ComputerVision/findingFeatures2_13.png)
> 하지만 **Harris Corner Detector 는 Image Scale 에 대해서는 Invariant 하지 않는다.**<br>
> - 좌측 이미지는 확대된 코너 이미지.<br>
>    - **Edge 로서 해석이 될 수 있다.**<br>
> - 우측 이미지는 축소된 코너 이미지.<br>
>    - **Corner 로서 해석이 될 수 있다.**<br>
> 		**--> Corner 에 적용된 Harris Detector 는 Scale 에 대해서 Invariant 하지 않음.**

<br><br>

## Blob (Binary Large OBjects) Detection
![path](/assets/images/INU/ComputerVision/findingFeatures2_14.png)
> **Image 내의 Pixel 들이 연결되어 있고 동시에 그룹(영역)을 가지고 있는 것.**<br>
> - **비슷한 속성을 공유**함. (색상, 밝기...)<br>
>   - 해당 속성은 **일시적이지 않고 꾸준히 유지되는 속성**이어야 함.<br>
> - 여러 형태의 모양이 포함됨.<br>
> - **컴퓨터 비전에서 가장 기본적인 Concept 로서 활용**된다.

<br><br>

### Blob Detection : Basic Idea
![path](/assets/images/INU/ComputerVision/findingFeatures2_15.png)
> **Image 에 대해 Blob Filter (Kernel) 을 Convolution.**<br>
> - response 를 얻을 수 있게 됨.<br>
>    - **밝은 부분 : Maxima**<br>
>    - **어두운 부분 : Minima**<br>
> - Response 를 통해 Blob 영역을 찾을 수 있는 단서를 얻을 수 있다.

<br><br>

### Blob Filter
![path](/assets/images/INU/ComputerVision/findingFeatures2_16.png)
> **Blob Filter 는 일반적으로 Gaussian 을 두 번 미분한 Laplacian of Gaussian (LoG) 를 활용한다.**<br>
> - LoG 는 Gaussian 의 속성을 따르기 때문에 **원형을 띄고 있음.**<br>
> - Gaussian 이기 때문에 **Circularly & Symmetric 함.**<br>
>     - **Gaussian 함수가 중심을 기준으로 원형 대칭을 가지고 있다는 의미.**<br>
>         - Gaussian 함수의 값은 **중심에서 최대가 되고 중심에서 멀어질수록 감소하는 형태**로 분포.<br>
>         - Gaussian 함수는 **회전에 대해서 대칭.**<br>
>             - **즉 어떤 각도로 회전하더라도 모양이 변하지 않음.**<br>
>             - 이러한 **원형 대칭성과 회전 대칭성은 이미지 처리에서 필터링 작업을 수행할 때 유용.**<br>
>             - 영상의 특정 방향 또는 회전에 민감하지 않도록 도와줌.

<br><br>

### Edge Detection with LoG
![path](/assets/images/INU/ComputerVision/findingFeatures2_17.png)
> Convolution 결과 그래프에서 **0을 거치는 순간의 점 근방이 Edge** 라고 판단 가능.

<br><br>

![path](/assets/images/INU/ComputerVision/findingFeatures2_18.png)
Original Signal 그래프의 Edge 부분을 나타내는 0 과 1 사이 변환 구간 == Edge
- **LoG Filter 를 적용 했을 때 0 을 거치는 순간과 같음.**
- 두 Edge 사이 값이 변하지 않고 일정.
	- 두 Edge 사이 구간은 Blob 이라고 볼 수 있음.

> **LoG 를 적용 (Convolution) 했을 때, Maximum & Minimum 이 발생하는 구간이 Blob 이다.** <br>
> **적절한 시그마를 찾는 것이 Blob 을 찾는 것에 있어 가장 중요함.**

<br><br>

### Scale Selection
![path](/assets/images/INU/ComputerVision/findingFeatures2_19.png)
> **Blob 의 특정 Scale 찾기.**<br>
> - LoG 를 사용해서 (Convolving) **Maximum Response** 를 찾을 것.<br>
> **문제점**<br>
> - Laplacian 에 대한 Response 는 Scale 이 커질수록 Response 가 작아짐.<br>
>     - 위 사진과 같이 Original signal 에 대해서 시그마 값이 커질수록 Laplacian Response (Kernel 에 대한 Response) 가 작아지는 것을 볼 수 있음.<br>
>     - 이는 Maximum Response 를 찾기 어려워짐.

<br><br>

### Scale Normalization
![path](/assets/images/INU/ComputerVision/findingFeatures2_20.png)
> Scale Selection 의 문제점 해결을 위해 나온 기법. <br><br>
> **LoG 의 시그마 값이 커질수록 Response 가 작아지는 문제.**<br><br>
> 이에 Response 를 유지하기 위해 Gaussian 에 시그마(Factor) 를 곱해 사용.<br><br>
> - **LoG 는 Gaussian 을 두 번 미분한 것이기 때문에 시그마의 제곱을 곱해 활용.**

<br><br>

**Effect of scale normalization**
![path](/assets/images/INU/ComputerVision/findingFeatures2_21.png)
> - 상단 그래프는 Scale normalization 적용 전.<br>
> - 하단 그래프는 Scale normalization 적용 후.<br>

- **Scale Normalization 을 통해 우리는 Blob에 적합한 Scale 의 크기를 찾아 낼 수 있다.**

<br><br>
### Scale Selection 문제 해결
> ![path](/assets/images/INU/ComputerVision/findingFeatures2_22.png)
> - **반지름이 r인 Blob에 대하여 Laplacian 이 가장 좋은 Maximum Response 를 나타내는 Scale의 크기는?**
> 	- **Sigma = r / √2**

<br><br>

> ![path](/assets/images/INU/ComputerVision/findingFeatures2_23.png)
> - Blob 의 Center 에서 가장 Peak 한 Laplacian Response 를 생성하는 Scale 을 **Characteristic Scale** 이라고 한다.

<br><br>

# SIFT Blob Detector and Descriptor



지식 공유 및 기록을 위한 컴퓨터 비전 개인 학습 포스트입니다.
피드백은 항상 환영합니다!
긴 글 읽어주셔서 감사합니다.
{: .notice--success}
{: style="text-align: center;"}

<br><br>

[처음으로~](#){: .btn .btn--primary }

### Task Lists

>

- [x] Invariant Descriptors
- [x] Scale
- [x] Rotation
- [x] View Point
- [x] Blob Detector
- [x] Harris Detector
- [x] Blob (Binary Large OBjects) Detection
- [x] Scale Selection
- [x] Scale Normalization
- [x] Scale Selection 문제 해결
- [x] SIFT Blob Detector and Descriptor
